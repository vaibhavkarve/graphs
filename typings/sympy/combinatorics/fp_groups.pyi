"""
This type stub file was generated by pyright.
"""

from sympy.combinatorics.free_groups import FreeGroupElement
from sympy.printing.defaults import DefaultPrinting
from sympy.utilities import public

"""Finitely Presented Groups and its algorithms. """
@public
def fp_group(fr_grp, relators=...): # -> tuple[FpGroup, *tuple[Any, ...]]:
    ...

@public
def xfp_group(fr_grp, relators=...): # -> tuple[FpGroup, Callable[[], Any]]:
    ...

@public
def vfp_group(fr_grpm, relators): # -> FpGroup:
    ...

class FpGroup(DefaultPrinting):
    """
    The FpGroup would take a FreeGroup and a list/tuple of relators, the
    relators would be specified in such a way that each of them be equal to the
    identity of the provided free group.

    """
    is_group = ...
    is_FpGroup = ...
    is_PermutationGroup = ...
    def __init__(self, fr_grp, relators) -> None:
        ...
    
    def make_confluent(self): # -> None:
        '''
        Try to make the group's rewriting system confluent

        '''
        ...
    
    def reduce(self, word):
        '''
        Return the reduced form of `word` in `self` according to the group's
        rewriting system. If it's confluent, the reduced form is the unique normal
        form of the word in the group.

        '''
        ...
    
    def equals(self, word1, word2): # -> bool | None:
        '''
        Compare `word1` and `word2` for equality in the group
        using the group's rewriting system. If the system is
        confluent, the returned answer is necessarily correct.
        (If it is not, `False` could be returned in some cases
        where in fact `word1 == word2`)

        '''
        ...
    
    @property
    def identity(self):
        ...
    
    def __contains__(self, g): # -> bool:
        ...
    
    def subgroup(self, gens, C=..., homomorphism=...): # -> tuple[FpGroup, GroupHomomorphism] | FpGroup:
        '''
        Return the subgroup generated by `gens` using the
        Reidemeister-Schreier algorithm
        homomorphism -- When set to True, return a dictionary containing the images
                     of the presentation generators in the original group.

        Examples
        ========

        >>> from sympy.combinatorics.fp_groups import FpGroup
        >>> from sympy.combinatorics import free_group
        >>> F, x, y = free_group("x, y")
        >>> f = FpGroup(F, [x**3, y**5, (x*y)**2])
        >>> H = [x*y, x**-1*y**-1*x*y*x]
        >>> K, T = f.subgroup(H, homomorphism=True)
        >>> T(K.generators)
        [x*y, x**-1*y**2*x**-1]

        '''
        ...
    
    def coset_enumeration(self, H, strategy=..., max_cosets=..., draft=..., incomplete=...): # -> CosetTable:
        """
        Return an instance of ``coset table``, when Todd-Coxeter algorithm is
        run over the ``self`` with ``H`` as subgroup, using ``strategy``
        argument as strategy. The returned coset table is compressed but not
        standardized.

        An instance of `CosetTable` for `fp_grp` can be passed as the keyword
        argument `draft` in which case the coset enumeration will start with
        that instance and attempt to complete it.

        When `incomplete` is `True` and the function is unable to complete for
        some reason, the partially complete table will be returned.

        """
        ...
    
    def standardize_coset_table(self): # -> None:
        """
        Standardized the coset table ``self`` and makes the internal variable
        ``_is_standardized`` equal to ``True``.

        """
        ...
    
    def coset_table(self, H, strategy=..., max_cosets=..., draft=..., incomplete=...): # -> list[list[None]]:
        """
        Return the mathematical coset table of ``self`` in ``H``.

        """
        ...
    
    def order(self, strategy=...): # -> int | Expr | Infinity:
        """
        Returns the order of the finitely presented group ``self``. It uses
        the coset enumeration with identity group as subgroup, i.e ``H=[]``.

        Examples
        ========

        >>> from sympy.combinatorics import free_group
        >>> from sympy.combinatorics.fp_groups import FpGroup
        >>> F, x, y = free_group("x, y")
        >>> f = FpGroup(F, [x, y**2])
        >>> f.order(strategy="coset_table_based")
        2

        """
        ...
    
    def most_frequent_generator(self):
        ...
    
    def random(self):
        ...
    
    def index(self, H, strategy=...): # -> int | Expr | Infinity:
        """
        Return the index of subgroup ``H`` in group ``self``.

        Examples
        ========

        >>> from sympy.combinatorics import free_group
        >>> from sympy.combinatorics.fp_groups import FpGroup
        >>> F, x, y = free_group("x, y")
        >>> f = FpGroup(F, [x**5, y**4, y*x*y**3*x**3])
        >>> f.index([x])
        4

        """
        ...
    
    def __str__(self) -> str:
        ...
    
    __repr__ = ...
    def derived_series(self): # -> list[Any]:
        '''
        Return the list of lists containing the generators
        of the subgroups in the derived series of `self`.

        '''
        ...
    
    def lower_central_series(self): # -> list[Any]:
        '''
        Return the list of lists containing the generators
        of the subgroups in the lower central series of `self`.

        '''
        ...
    
    def center(self): # -> list[Any]:
        '''
        Return the list of generators of the center of `self`.

        '''
        ...
    
    def derived_subgroup(self): # -> list[Any]:
        '''
        Return the list of generators of the derived subgroup of `self`.

        '''
        ...
    
    def centralizer(self, other): # -> list[Any]:
        '''
        Return the list of generators of the centralizer of `other`
        (a list of elements of `self`) in `self`.

        '''
        ...
    
    def normal_closure(self, other): # -> list[Any]:
        '''
        Return the list of generators of the normal closure of `other`
        (a list of elements of `self`) in `self`.

        '''
        ...
    
    @property
    def is_abelian(self): # -> Any:
        '''
        Check if `self` is abelian.

        '''
        ...
    
    @property
    def is_nilpotent(self): # -> Any:
        '''
        Check if `self` is nilpotent.

        '''
        ...
    
    @property
    def is_solvable(self): # -> Any:
        '''
        Check if `self` is solvable.

        '''
        ...
    
    @property
    def elements(self): # -> list[Any] | None:
        '''
        List the elements of `self`.

        '''
        ...
    
    @property
    def is_cyclic(self): # -> bool:
        """
        Return ``True`` if group is Cyclic.

        """
        ...
    
    def abelian_invariants(self): # -> list[Any]:
        """
        Return Abelian Invariants of a group.
        """
        ...
    
    def composition_series(self): # -> list[Any]:
        """
        Return subnormal series of maximum length for a group.
        """
        ...
    


class FpSubgroup(DefaultPrinting):
    '''
    The class implementing a subgroup of an FpGroup or a FreeGroup
    (only finite index subgroups are supported at this point). This
    is to be used if one wishes to check if an element of the original
    group belongs to the subgroup

    '''
    def __init__(self, G, gens, normal=...) -> None:
        ...
    
    def __contains__(self, g): # -> bool:
        ...
    
    def order(self): # -> One | Infinity:
        ...
    
    def to_FpGroup(self): # -> FreeGroup:
        ...
    
    def __str__(self) -> str:
        ...
    
    __repr__ = ...


def low_index_subgroups(G, N, Y=...): # -> list[Any]:
    """
    Implements the Low Index Subgroups algorithm, i.e find all subgroups of
    ``G`` upto a given index ``N``. This implements the method described in
    [Sim94]. This procedure involves a backtrack search over incomplete Coset
    Tables, rather than over forced coincidences.

    Parameters
    ==========

    G: An FpGroup < X|R >
    N: positive integer, representing the maximum index value for subgroups
    Y: (an optional argument) specifying a list of subgroup generators, such
    that each of the resulting subgroup contains the subgroup generated by Y.

    Examples
    ========

    >>> from sympy.combinatorics import free_group
    >>> from sympy.combinatorics.fp_groups import FpGroup, low_index_subgroups
    >>> F, x, y = free_group("x, y")
    >>> f = FpGroup(F, [x**2, y**3, (x*y)**4])
    >>> L = low_index_subgroups(f, 4)
    >>> for coset_table in L:
    ...     print(coset_table.table)
    [[0, 0, 0, 0]]
    [[0, 0, 1, 2], [1, 1, 2, 0], [3, 3, 0, 1], [2, 2, 3, 3]]
    [[0, 0, 1, 2], [2, 2, 2, 0], [1, 1, 0, 1]]
    [[1, 1, 0, 0], [0, 0, 1, 1]]

    References
    ==========

    .. [1] Holt, D., Eick, B., O'Brien, E.
           "Handbook of Computational Group Theory"
           Section 5.4

    .. [2] Marston Conder and Peter Dobcsanyi
           "Applications and Adaptions of the Low Index Subgroups Procedure"

    """
    ...

def descendant_subgroups(S, C, R1_c_list, x, R2, N, Y): # -> None:
    ...

def try_descendant(S, C, R1_c_list, R2, N, alpha, x, beta, Y): # -> None:
    r"""
    Solves the problem of trying out each individual possibility
    for `\alpha^x.

    """
    ...

def first_in_class(C, Y=...): # -> bool:
    """
    Checks whether the subgroup ``H=G1`` corresponding to the Coset Table
    could possibly be the canonical representative of its conjugacy class.

    Parameters
    ==========

    C: CosetTable

    Returns
    =======

    bool: True/False

    If this returns False, then no descendant of C can have that property, and
    so we can abandon C. If it returns True, then we need to process further
    the node of the search tree corresponding to C, and so we call
    ``descendant_subgroups`` recursively on C.

    Examples
    ========

    >>> from sympy.combinatorics import free_group
    >>> from sympy.combinatorics.fp_groups import FpGroup, CosetTable, first_in_class
    >>> F, x, y = free_group("x, y")
    >>> f = FpGroup(F, [x**2, y**3, (x*y)**4])
    >>> C = CosetTable(f, [])
    >>> C.table = [[0, 0, None, None]]
    >>> first_in_class(C)
    True
    >>> C.table = [[1, 1, 1, None], [0, 0, None, 1]]; C.p = [0, 1]
    >>> first_in_class(C)
    True
    >>> C.table = [[1, 1, 2, 1], [0, 0, 0, None], [None, None, None, 0]]
    >>> C.p = [0, 1, 2]
    >>> first_in_class(C)
    False
    >>> C.table = [[1, 1, 1, 2], [0, 0, 2, 0], [2, None, 0, 1]]
    >>> first_in_class(C)
    False

    # TODO:: Sims points out in [Sim94] that performance can be improved by
    # remembering some of the information computed by ``first_in_class``. If
    # the ``continue alpha`` statement is executed at line 14, then the same thing
    # will happen for that value of alpha in any descendant of the table C, and so
    # the values the values of alpha for which this occurs could profitably be
    # stored and passed through to the descendants of C. Of course this would
    # make the code more complicated.

    # The code below is taken directly from the function on page 208 of [Sim94]
    # nu[alpha]

    """
    ...

def simplify_presentation(*args, change_gens=...):
    '''
    For an instance of `FpGroup`, return a simplified isomorphic copy of
    the group (e.g. remove redundant generators or relators). Alternatively,
    a list of generators and relators can be passed in which case the
    simplified lists will be returned.

    By default, the generators of the group are unchanged. If you would
    like to remove redundant generators, set the keyword argument
    `change_gens = True`.

    '''
    ...

def elimination_technique_1(gens, rels, identity): # -> tuple[list[Any], list[Any]]:
    ...

def define_schreier_generators(C, homomorphism=...): # -> None:
    '''
    Parameters
    ==========

    C -- Coset table.
    homomorphism -- When set to True, return a dictionary containing the images
                     of the presentation generators in the original group.
    '''
    ...

def reidemeister_relators(C): # -> None:
    ...

def rewrite(C, alpha, w):
    """
    Parameters
    ==========

    C: CosetTable
    alpha: A live coset
    w: A word in `A*`

    Returns
    =======

    rho(tau(alpha), w)

    Examples
    ========

    >>> from sympy.combinatorics.fp_groups import FpGroup, CosetTable, define_schreier_generators, rewrite
    >>> from sympy.combinatorics import free_group
    >>> F, x, y = free_group("x, y")
    >>> f = FpGroup(F, [x**2, y**3, (x*y)**6])
    >>> C = CosetTable(f, [])
    >>> C.table = [[1, 1, 2, 3], [0, 0, 4, 5], [4, 4, 3, 0], [5, 5, 0, 2], [2, 2, 5, 1], [3, 3, 1, 4]]
    >>> C.p = [0, 1, 2, 3, 4, 5]
    >>> define_schreier_generators(C)
    >>> rewrite(C, 0, (x*y)**6)
    x_4*y_2*x_3*x_1*x_2*y_4*x_5

    """
    ...

def elimination_technique_2(C): # -> tuple[Any, Any | list[Any]]:
    """
    This technique eliminates one generator at a time. Heuristically this
    seems superior in that we may select for elimination the generator with
    shortest equivalent string at each stage.

    >>> from sympy.combinatorics import free_group
    >>> from sympy.combinatorics.fp_groups import FpGroup, coset_enumeration_r, \
            reidemeister_relators, define_schreier_generators, elimination_technique_2
    >>> F, x, y = free_group("x, y")
    >>> f = FpGroup(F, [x**3, y**5, (x*y)**2]); H = [x*y, x**-1*y**-1*x*y*x]
    >>> C = coset_enumeration_r(f, H)
    >>> C.compress(); C.standardize()
    >>> define_schreier_generators(C)
    >>> reidemeister_relators(C)
    >>> elimination_technique_2(C)
    ([y_1, y_2], [y_2**-3, y_2*y_1*y_2*y_1*y_2*y_1, y_1**2])

    """
    ...

def reidemeister_presentation(fp_grp, H, C=..., homomorphism=...): # -> tuple[tuple[Any, ...], tuple[Any, ...], list[Any]] | tuple[tuple[Any, ...], tuple[Any, ...]]:
    """
    Parameters
    ==========

    fp_group: A finitely presented group, an instance of FpGroup
    H: A subgroup whose presentation is to be found, given as a list
    of words in generators of `fp_grp`
    homomorphism: When set to True, return a homomorphism from the subgroup
                    to the parent group

    Examples
    ========

    >>> from sympy.combinatorics import free_group
    >>> from sympy.combinatorics.fp_groups import FpGroup, reidemeister_presentation
    >>> F, x, y = free_group("x, y")

    Example 5.6 Pg. 177 from [1]
    >>> f = FpGroup(F, [x**3, y**5, (x*y)**2])
    >>> H = [x*y, x**-1*y**-1*x*y*x]
    >>> reidemeister_presentation(f, H)
    ((y_1, y_2), (y_1**2, y_2**3, y_2*y_1*y_2*y_1*y_2*y_1))

    Example 5.8 Pg. 183 from [1]
    >>> f = FpGroup(F, [x**3, y**3, (x*y)**3])
    >>> H = [x*y, x*y**-1]
    >>> reidemeister_presentation(f, H)
    ((x_0, y_0), (x_0**3, y_0**3, x_0*y_0*x_0*y_0*x_0*y_0))

    Exercises Q2. Pg 187 from [1]
    >>> f = FpGroup(F, [x**2*y**2, y**-1*x*y*x**-3])
    >>> H = [x]
    >>> reidemeister_presentation(f, H)
    ((x_0,), (x_0**4,))

    Example 5.9 Pg. 183 from [1]
    >>> f = FpGroup(F, [x**3*y**-3, (x*y)**3, (x*y**-1)**2])
    >>> H = [x]
    >>> reidemeister_presentation(f, H)
    ((x_0,), (x_0**6,))

    """
    ...

FpGroupElement = FreeGroupElement
